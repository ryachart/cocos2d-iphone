////  SWTableView.m//  SWGameLib////  Copyright (c) 2010 Sangwoo Im////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//  ////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#import "CCTableView.h"#import "CCTableViewCell.h"#import "CCMenu.h"#import "CGPointExtension.h"#import "CCSorting.h"#import "CCLayer.h"#import "CCAction.h"#import "CCActionInterval.h"#import "CCActionEase.h"#import "CCDirector.h"#import "CCActionInstant.h"@interface CCScrollView()@property (nonatomic, assign) BOOL    touchMoved_;@property (nonatomic, retain) CCLayer *container_;@property (nonatomic, assign) CGPoint touchPoint_;@end@interface CCTableView ()-(NSInteger)__indexFromOffset:(CGPoint)offset;-(NSUInteger)_indexFromOffset:(CGPoint)offset;-(CGPoint)__offsetFromIndex:(NSInteger)index;-(CGPoint)_offsetFromIndex:(NSUInteger)index;-(void)_updateContentSize;@end@interface CCTableView (Private)- (CCTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex;- (void)_moveCellOutOfSight:(CCTableViewCell *)cell;- (void)_setIndex:(NSUInteger)index forCell:(CCTableViewCell *)cell;- (void)_addCellIfNecessary:(CCTableViewCell *)cell;@end@implementation CCTableView@synthesize delegate   = tDelegate_;@synthesize dataSource = dataSource_;@synthesize verticalFillOrder  = vordering_;+(id)viewWithDataSource:(id<CCTableViewDataSource>)dataSource size:(CGSize)size {    return [self viewWithDataSource:dataSource size:size container:nil];}+(id)viewWithDataSource:(id <CCTableViewDataSource>)dataSource size:(CGSize)size container:(CCNode *)container {    CCTableView *table;    table = [[[self alloc] initWithViewSize:size container:container] autorelease];    table.dataSource = dataSource;    [table _updateContentSize];    return table;}-(id)initWithViewSize:(CGSize)size container:(CCNode *)container {    if ((self = [super initWithViewSize:size container:container])) {        cellsUsed_      = [NSMutableArray new];        cellsFreed_     = [NSMutableArray new];        indices_        = [NSMutableIndexSet new];        tDelegate_      = nil;        vordering_      = SWTableViewFillBottomUp;        self.direction  = SWScrollViewDirectionVertical;                [super setDelegate:self];    }    return self;}-(void)dealloc {    [indices_    release];    [cellsUsed_  release];    [cellsFreed_ release];    [super dealloc];}#pragma mark - #pragma mark property-(void)setVerticalFillOrder:(SWTableViewVerticalFillOrder)fillOrder {    if (vordering_ != fillOrder) {        vordering_ = fillOrder;        if ([cellsUsed_ count] > 0) {            [self reloadData];        }    }}#pragma mark -#pragma mark public-(void)reloadData {    NSAutoreleasePool *pool;        pool = [NSAutoreleasePool new];    for (CCTableViewCell *cell in cellsUsed_) {        [cellsFreed_ addObject:cell];        [cell reset];        if (cell.parent == self.container_) {            [container_ removeChild:cell cleanup:YES];        }    }    [indices_ removeAllIndexes];    [cellsUsed_ release];    cellsUsed_ = [NSMutableArray new];        [self _updateContentSize];    if ([dataSource_ numberOfCellsInTableView:self] > 0) {        [self scrollViewDidScroll:self];    }    [pool drain];}-(CCTableViewCell *)cellAtIndex:(NSUInteger)idx {    return [self _cellWithIndex:idx];}-(void)updateCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }        CCTableViewCell   *cell;        cell = [self _cellWithIndex:idx];    if (cell) {        [self _moveCellOutOfSight:cell];    }     cell = [dataSource_ table:self cellAtIndex:idx];    [self _setIndex:idx forCell:cell];    [self _addCellIfNecessary:cell];}-(void)insertCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }    CCTableViewCell   *cell;    NSInteger         newIdx;        cell        = [cellsUsed_ objectWithObjectID:idx];    if (cell) {        newIdx = [cellsUsed_ indexOfSortedObject:cell];        for (int i=newIdx; i<[cellsUsed_ count]; i++) {            cell = [cellsUsed_ objectAtIndex:i];            [self _setIndex:cell.idx+1 forCell:cell];        }    }        [indices_ shiftIndexesStartingAtIndex:idx by:1];        //insert a new cell    cell = [dataSource_ table:self cellAtIndex:idx];    [self _setIndex:idx forCell:cell];    [self _addCellIfNecessary:cell];        [self _updateContentSize];}-(void)removeCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }        CCTableViewCell   *cell;    NSInteger         newIdx;        cell = [self _cellWithIndex:idx];    if (!cell) {        return;    }        newIdx = [cellsUsed_ indexOfSortedObject:cell];        //remove first    [self _moveCellOutOfSight:cell];        [indices_ shiftIndexesStartingAtIndex:idx+1 by:-1];    for (int i=[cellsUsed_ count]-1; i > newIdx; i--) {        cell = [cellsUsed_ objectAtIndex:i];        [self _setIndex:cell.idx-1 forCell:cell];    }}-(CCTableViewCell *)dequeueCell {    CCTableViewCell *cell;        if ([cellsFreed_ count] == 0) {        cell = nil;    } else {        cell = [[cellsFreed_ objectAtIndex:0] retain];        [cellsFreed_ removeObjectAtIndex:0];    }    return [cell autorelease];}-(void)animateCellsOffscreenWithCompletion:(CompletionBlock)completion {    self.isTouchEnabled = NO;    const float completionTime = .5;    for (CCTableViewCell *cell in cellsUsed_) {        [cell runAction:[CCEaseBackOut actionWithAction:[CCMoveTo actionWithDuration:completionTime / 2.0 position:CGPointMake([CCDirector sharedDirector].winSize.width + cell.contentSize.width + 20, cell.position.y)]]];    }        [self runAction:[CCSequence actionOne:[CCDelayTime actionWithDuration:completionTime] two:[CCCallBlock actionWithBlock:completion]]];    }-(void)restoreCells {    self.isTouchEnabled = YES;    [self reloadData];}#pragma mark -#pragma mark private- (void)_addCellIfNecessary:(CCTableViewCell *)cell {    if (cell.parent != self.container_) {        [self.container_ addChild:cell];    }    [cellsUsed_ insertSortedObject:cell];    [indices_ addIndex:cell.idx];}- (void)_updateContentSize {    CGSize     size, cellSize;    NSUInteger cellCount;        cellSize  = [dataSource_ cellSizeForTable:self];    cellCount = [dataSource_ numberOfCellsInTableView:self];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            size = CGSizeMake(cellCount * cellSize.width, cellSize.height);            break;        default:            size = CGSizeMake(cellSize.width, cellCount * cellSize.height);            break;    }    [self setContentSize:size];}- (CGPoint)_offsetFromIndex:(NSUInteger)index {    CGPoint offset = [self __offsetFromIndex:index];        const CGSize cellSize = [dataSource_ cellSizeForTable:self];    if (vordering_ == SWTableViewFillTopDown) {        offset.y = container_.contentSize.height - offset.y - cellSize.height;    }    return offset;}- (CGPoint)__offsetFromIndex:(NSInteger)index {    CGPoint offset;    CGSize  cellSize;        cellSize = [dataSource_ cellSizeForTable:self];    switch (self.direction) {        case SWScrollViewDirectionHorizontal:            offset = ccp(cellSize.width * index, 0.0f);            break;        default:            offset = ccp(0.0f, cellSize.height * index);            break;    }        return offset;}- (NSUInteger)_indexFromOffset:(CGPoint)offset {    NSInteger index;    const NSInteger maxIdx = [dataSource_ numberOfCellsInTableView:self]-1;        const CGSize cellSize = [dataSource_ cellSizeForTable:self];    if (vordering_ == SWTableViewFillTopDown) {        offset.y = container_.contentSize.height - offset.y - cellSize.height;    }    index = MAX(0, [self __indexFromOffset:offset]);    index = MIN(index, maxIdx);    return index;}- (NSInteger)__indexFromOffset:(CGPoint)offset {    NSInteger  index;    CGSize     cellSize;        cellSize = [dataSource_ cellSizeForTable:self];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            index = offset.x/cellSize.width;            break;        default:            index = offset.y/cellSize.height;            break;    }        return index;}- (CCTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex {    CCTableViewCell *found;        found = nil;        if ([indices_ containsIndex:cellIndex]) {        found = (CCTableViewCell *)[cellsUsed_ objectWithObjectID:cellIndex];    }        return found;}- (void)_moveCellOutOfSight:(CCTableViewCell *)cell {    [cellsFreed_ addObject:cell];    [cellsUsed_ removeSortedObject:cell];    [indices_ removeIndex:cell.idx];    [cell reset];    if (cell.parent == self.container_) {        [container_ removeChild:cell cleanup:YES];    }}- (void)_setIndex:(NSUInteger)index forCell:(CCTableViewCell *)cell {    cell.anchorPoint = ccp(0.0f, 0.0f);    cell.position    = [self _offsetFromIndex:index];    cell.idx         = index;}#pragma mark -#pragma mark scrollView-(void)scrollViewDidScroll:(CCScrollView *)view {    NSUInteger        startIdx, endIdx, idx, maxIdx;    CGPoint           offset;    NSAutoreleasePool *pool;        pool     = [NSAutoreleasePool new];    offset   = ccpMult([self contentOffset], -1);    maxIdx   = MAX([dataSource_ numberOfCellsInTableView:self]-1, 0);        const CGSize cellSize = [dataSource_ cellSizeForTable:self];        if (vordering_ == SWTableViewFillTopDown) {        offset.y = offset.y + viewSize_.height/container_.scaleY - cellSize.height;    }    startIdx = [self _indexFromOffset:offset];    if (vordering_ == SWTableViewFillTopDown) {        offset.y -= viewSize_.height/container_.scaleY;    } else {        offset.y += viewSize_.height/container_.scaleY;    }    offset.x += viewSize_.width/container_.scaleX;        endIdx   = [self _indexFromOffset:offset];               if ([cellsUsed_ count] > 0) {        idx = [[cellsUsed_ objectAtIndex:0] idx];        while(idx <startIdx) {            CCTableViewCell *cell = [cellsUsed_ objectAtIndex:0];            [self _moveCellOutOfSight:cell];            if ([cellsUsed_ count] > 0) {                idx = [[cellsUsed_ objectAtIndex:0] idx];                 } else {                break;            }        }    }    if ([cellsUsed_ count] > 0) {        idx = [[cellsUsed_ lastObject] idx];        while(idx <= maxIdx && idx > endIdx) {            CCTableViewCell *cell = [cellsUsed_ lastObject];            [self _moveCellOutOfSight:cell];            if ([cellsUsed_ count] > 0) {                idx = [[cellsUsed_ lastObject] idx];               } else {                break;            }        }    }        for (NSUInteger i=startIdx; i <= endIdx; i++) {        if ([indices_ containsIndex:i]) {            continue;        }        [self updateCellAtIndex:i];    }    [pool drain];}#pragma mark -#pragma mark Touch events-(void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {    if (!self.visible) {        return;    }    if ([touches_ count] == 1 && !self.touchMoved_) {        NSUInteger        index;        CCTableViewCell   *cell;        CGPoint           point;                point = [container_ convertTouchToNodeSpace:touch];        if (vordering_ == SWTableViewFillTopDown) {            CGSize cellSize = [dataSource_ cellSizeForTable:self];            point.y -= cellSize.height;        }        index = [self _indexFromOffset:point];        cell  = [self _cellWithIndex:index];                if (cell) {            [tDelegate_ table:self cellTouched:cell];           }    }    [super ccTouchEnded:touch withEvent:event];}@end